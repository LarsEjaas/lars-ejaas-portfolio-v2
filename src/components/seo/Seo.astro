---
import type { metaTag, SeoProps } from '@customTypes/seo';
import {
  languages as availableLanguages,
  defaultLang,
  type Language,
} from '@i18n/settings';
import Favicon from './Favicon.astro';
import { getDefaultSiteMetaData } from './siteMetaData';
import { getLangFromUrl } from '@i18n/utils';
import type { ImageInputFormat } from 'astro';
const isDev = import.meta.env.DEV || false;

type Props = {} & SeoProps & {
    metaTags?: metaTag[];
    noIndex?: true;
    noFollow?: true;
  };

type ImageMetadataReturn = {
  src: string;
  width: number;
  height: number;
  mimeType: ImageMimeType<ImageInputFormat>;
};

type ImageMimeType<T extends ImageInputFormat> = T extends 'svg'
  ? 'image/svg+xml'
  : `image/${T}`;

/** Validate path to meta image at build time */
export async function validateAndGetPublicPath(
  imageName: string
): Promise<ImageMetadataReturn> {
  const metaImages = import.meta.glob<ImageMetadata>(
    '/public/**/*.{jpg,jpeg,png,tiff,webp,gif,avif}',
    {
      import: 'default',
      eager: true,
    }
  );

  const getImageMimeType = (
    format: ImageInputFormat
  ): ImageMimeType<typeof format> => {
    return format === 'svg'
      ? 'image/svg+xml'
      : (`image/${format}` as ImageMimeType<typeof format>);
  };

  const imageEntry = Object.entries(metaImages).find(([path]) =>
    path.includes(imageName)
  );

  if (!imageEntry) {
    throw new Error(`Meta image not found: ${imageName} in the SEO component`);
  }

  const [path, metadata] = imageEntry;

  if (!metadata?.width || !metadata?.height) {
    throw new Error(
      `Invalid metadata for image: ${imageName} in the SEO component. Missing width or height.`
    );
  }

  const mimeType = getImageMimeType(metadata.format);

  return {
    src: path.replace('/public', ''),
    width: metadata.width,
    height: metadata.height,
    mimeType,
  };
}

const lang = getLangFromUrl(Astro.url);

const defaultSiteMetaData = await getDefaultSiteMetaData(lang);

const languages = Object.keys(availableLanguages) as Language[];

const {
  metaData,
  metaTheme,
  twitter,
  openGraph,
  metaTags: additionalMetaTags,
  noIndex,
  noFollow,
} = Astro.props;

if (openGraph?.image?.name && !openGraph?.image?.alt) {
  const error =
    "WARNING(SEO): You defined `openGraph.image.name`, but didn't define `openGraph.image.alt`. This is strongly discouraged.'";
  if (isDev) {
    throw new Error(error);
  }
  console.warn(error);
}

// Determine image details
const imageName =
  openGraph?.image?.name ?? defaultSiteMetaData.openGraph.image.name;

const publicImage = await validateAndGetPublicPath(imageName);

// Construct canonical URL
const baseUrl = Astro.site ?? Astro.url;
const defaultCanonicalUrl = new URL(
  Astro.url.pathname + Astro.url.search,
  baseUrl
);
const canonicalUrl = defaultCanonicalUrl.href;

const pageTitle = metaData?.title
  ? `Lars Ejaas | ${metaData?.title}`
  : `Lars Ejaas | ${defaultSiteMetaData.metaData.title}`;

// Generate meta tags dynamically
const metaTags: metaTag[] = [
  // Description
  {
    name: 'description',
    content: metaData?.description || defaultSiteMetaData.metaData.description,
  },
  {
    name: 'keywords',
    content: (metaData?.keywords || defaultSiteMetaData.metaData.keywords).join(
      ','
    ),
  },

  // Open Graph
  {
    property: 'og:title',
    content: pageTitle,
  },
  {
    property: 'og:description',
    content: metaData?.description || defaultSiteMetaData.metaData.description,
  },
  { property: 'og:url', content: canonicalUrl },
  {
    property: 'og:site_name',
    content: defaultSiteMetaData.metaData.siteName,
  },
  { property: 'og:locale', content: lang === defaultLang ? 'en_US' : 'da_DK' },
  { property: 'og:locale:alternate', content: 'en_US' },
  { property: 'og:locale:alternate', content: 'da_DK' },
  { property: 'og:type', content: openGraph?.type ?? 'website' },
  { property: 'og:image:url', content: publicImage.src },
  { property: 'og:image:secure_url', content: publicImage.src },
  { property: 'og:image:type', content: publicImage.mimeType },
  { property: 'og:image:width', content: `${publicImage.width}` },
  {
    property: 'og:image:height',
    content: `${publicImage.height}`,
  },
  ...(openGraph?.image?.alt
    ? [{ property: 'og:image:alt', content: openGraph.image.alt }]
    : []),

  // Twitter Card
  { name: 'twitter:card', content: 'summary_large_image' },
  {
    name: 'twitter:title',
    content: pageTitle,
  },
  {
    name: 'twitter:description',
    content: metaData?.description || defaultSiteMetaData.metaData.description,
  },
  { name: 'twitter:image', content: publicImage.src },
  ...(openGraph?.image?.alt
    ? [{ property: 'twitter:image:alt', content: openGraph.image.alt }]
    : []),
  ...(additionalMetaTags ? additionalMetaTags : []),
];

// Conditionally add Twitter creator/site if provided
if (twitter?.creator)
  metaTags.push({ name: 'twitter:creator', content: twitter.creator });
if (twitter?.site)
  metaTags.push({ name: 'twitter:site', content: twitter.site });

// Add article-specific Open Graph tags if available
if (openGraph && 'article' in openGraph && openGraph.article) {
  if (openGraph.article.publishedTime) {
    metaTags.push({
      property: 'article:published_time',
      content: openGraph.article.publishedTime,
    });
  }
  if (openGraph.article.modifiedTime) {
    metaTags.push({
      property: 'article:modified_time',
      content: openGraph.article.modifiedTime,
    });
  }
  if (openGraph.article.expirationTime) {
    metaTags.push({
      property: 'article:expiration_time',
      content: openGraph.article.modifiedTime,
    });
  }
  if (openGraph.article.authors) {
    openGraph.article.authors.forEach((author) => {
      metaTags.push({
        property: 'article:author',
        content: author,
      });
    });
  }
  if (openGraph.article.section) {
    metaTags.push({
      property: 'article:section',
      content: openGraph.article.section,
    });
  }
  if (openGraph.article.tags) {
    openGraph.article.tags.forEach((tag) =>
      metaTags.push({ property: 'article:tag', content: tag })
    );
  }
}
---

<!-- Title -->
<title>{pageTitle}</title>
<link rel="canonical" href={canonicalUrl} />

<!-- Theme -->
<Favicon metaTheme={defaultSiteMetaData.metaTheme} />
{
  (
    metaTheme?.appleTouchIcon || defaultSiteMetaData.metaTheme.appleTouchIcon
  )?.sizes.map(async (size) => {
    const icon = await validateAndGetPublicPath(
      `${defaultSiteMetaData.metaTheme.appleTouchIcon?.path}icon-${size}x${size}`
    );
    return (
      <link
        rel="apple-touch-icon"
        sizes={`${icon.width}x${icon.height}`}
        href={icon.src}
      />
    );
  })
}
<meta
  name="theme-color"
  content={metaTheme?.themeColor || defaultSiteMetaData.metaTheme.themeColor}
/>

<!-- Dynamic Meta Tags -->
{
  metaTags.map(
    ({ name, property, content, 'http-equiv': httpEquiv, media }) => (
      <meta
        name={name}
        content={content}
        property={property}
        http-equiv={httpEquiv}
        media={media}
      />
    )
  )
}

<!-- Internationalization -->
{
  languages.map((lang) => (
    <>
      <link
        rel="alternate"
        hreflang={lang}
        href={`https://larsejaas.com/${lang}/`}
      />
      <link rel="alternate" href={Astro.url} hreflang="x-default" />
      <link rel="alternate" href="https://larsejaas.com/en/" hreflang={lang} />
    </>
  ))
}

<meta
  name="robots"
  content={`${noIndex ? 'noindex' : 'index'}, ${
    noFollow ? 'nofollow' : 'follow'
  }`}
/>

<!-- Structured JSON-LD -->
<script
  is:inline
  type="application/ld+json"
  set:html={JSON.stringify({
    '@context': 'https://schema.org',
    '@type': 'WebPage',
    headline: pageTitle,
    description:
      metaData?.description || defaultSiteMetaData.metaData.description,
    author: {
      '@type': 'Person',
      name: metaData?.author || defaultSiteMetaData.metaData.author,
    },
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': canonicalUrl,
    },
  })}
/>

<slot />

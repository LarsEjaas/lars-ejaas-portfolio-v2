---
import type { metaTag, SeoProps } from '@customTypes/seo';
import { languages as availableLanguages, type Language } from '@i18n/settings';
import Favicon from './Favicon.astro';
import { getDefaultSiteMetaData } from './siteMetaData';
import { getLangFromUrl } from '@i18n/utils';

type Props = {} & SeoProps;

type ImageMetadataReturn = {
  src: string;
  width: number;
  height: number;
};

/** Validate path to meta image at build time */
async function validateAndGetPublicPath(
  imageName: string
): Promise<ImageMetadataReturn> {
  const metaImages = import.meta.glob<ImageMetadata>(
    '/public/openGraphImages/*.{jpg,png}',
    {
      import: 'default',
      eager: true,
    }
  );

  const imageEntry = Object.entries(metaImages).find(([path]) =>
    path.includes(imageName)
  );

  if (!imageEntry) {
    throw new Error(`Meta image not found: ${imageName} in the SEO component`);
  }

  const [path, metadata] = imageEntry;

  if (!metadata?.width || !metadata?.height) {
    throw new Error(
      `Invalid metadata for image: ${imageName} in the SEO component. Missing width or height.`
    );
  }

  return {
    src: path.replace('/public', ''),
    width: metadata.width,
    height: metadata.height,
  };
}

const lang = getLangFromUrl(Astro.url);

const defaultSiteMetaData = getDefaultSiteMetaData(lang);

const languages = Object.keys(availableLanguages) as Language[];

const {
  metaData,
  metaTheme,
  //facebook,
  twitter,
  openGraph,
} = Astro.props;

// Determine image details
const imageUrl = openGraph?.image ?? defaultSiteMetaData.openGraph.image;

const publicImageUrl = await validateAndGetPublicPath(imageUrl);

// Construct canonical URL
const canonicalUrl = new URL(
  Astro.url.pathname,
  metaData?.siteUrl || defaultSiteMetaData.metaData.siteUrl
).toString();

// Generate meta tags dynamically
const metaTags: metaTag[] = [
  // Description
  {
    name: 'description',
    content: metaData?.description || defaultSiteMetaData.metaData.description,
  },
  {
    name: 'keywords',
    content: (metaData?.keywords || defaultSiteMetaData.metaData.keywords).join(
      ','
    ),
  },

  // Open Graph
  {
    property: 'og:title',
    content: metaData?.title || defaultSiteMetaData.metaData.title,
  },
  {
    property: 'og:description',
    content: metaData?.description || defaultSiteMetaData.metaData.description,
  },
  { property: 'og:url', content: canonicalUrl },
  {
    property: 'og:site_name',
    content: metaData?.title || defaultSiteMetaData.metaData.title,
  },
  { property: 'og:type', content: openGraph?.type ?? 'website' },
  { property: 'og:image', content: publicImageUrl.src },
  { property: 'og:image:width', content: `${publicImageUrl.width}` },
  {
    property: 'og:image:height',
    content: `${publicImageUrl.height}`,
  },

  // Twitter Card
  { name: 'twitter:card', content: 'summary_large_image' },
  {
    name: 'twitter:title',
    content: metaData?.title || defaultSiteMetaData.metaData.title,
  },
  {
    name: 'twitter:description',
    content: metaData?.description || defaultSiteMetaData.metaData.description,
  },
  { name: 'twitter:image', content: publicImageUrl.src },
];

// Conditionally add Twitter creator/site if provided
if (twitter?.creator)
  metaTags.push({ name: 'twitter:creator', content: twitter.creator });
if (twitter?.site)
  metaTags.push({ name: 'twitter:site', content: twitter.site });

// Add article-specific Open Graph tags if available
if (openGraph?.article) {
  if (openGraph.article.publishedTime)
    metaTags.push({
      property: 'article:published_time',
      content: openGraph.article.publishedTime,
    });
  if (openGraph.article.modifiedTime)
    metaTags.push({
      property: 'article:modified_time',
      content: openGraph.article.modifiedTime,
    });
  if (openGraph.article.section)
    metaTags.push({
      property: 'article:section',
      content: openGraph.article.section,
    });
  if (openGraph.article.tags)
    openGraph.article.tags.forEach((tag) =>
      metaTags.push({ property: 'article:tag', content: tag })
    );
}
---

<!-- Title -->
<title>{metaData?.title || defaultSiteMetaData.metaData.title}</title>
<link rel="canonical" href={canonicalUrl} />

<Favicon metaTheme={metaTheme || defaultSiteMetaData.metaTheme} />

<!-- Apple Touch Icons -->
{
  (
    metaTheme?.appleTouchIcon || defaultSiteMetaData.metaTheme.appleTouchIcon
  )?.sizes.map((size) => (
    <link
      rel="apple-touch-icon"
      sizes={`${size}x${size}`}
      href={`${(metaTheme?.appleTouchIcon || defaultSiteMetaData.metaTheme.appleTouchIcon)?.path}icon-${size}x${size}.png`}
    />
  ))
}

<!-- Theme Color -->
<meta
  name="theme-color"
  content={metaTheme?.themeColor || defaultSiteMetaData.metaTheme.themeColor}
/>

<!-- Dynamic Meta Tags -->
{
  metaTags.map(({ name, property, content }) =>
    name ? (
      <meta name={name} content={content} />
    ) : (
      <meta property={property} content={content} />
    )
  )
}

<!-- Internationalization -->
{
  languages.map((lang) => (
    <>
      <link
        rel="alternate"
        hreflang={lang}
        href={`https://larsejaas.com/${lang}/`}
      />
      <link rel="alternate" href={Astro.url} hreflang="x-default" />
      <link rel="alternate" href="https://larsejaas.com/en/" hreflang={lang} />
    </>
  ))
}

<!-- Structured JSON-LD -->
<script
  is:inline
  type="application/ld+json"
  set:html={JSON.stringify({
    '@context': 'https://schema.org',
    '@type': 'WebPage',
    headline: metaData?.title || defaultSiteMetaData.metaData.title,
    description:
      metaData?.description || defaultSiteMetaData.metaData.description,
    author: {
      '@type': 'Person',
      name: metaData?.author || defaultSiteMetaData.metaData.author,
    },
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': canonicalUrl,
    },
  })}
/>

<slot />
